created: 20220919210136371
modified: 20221009221314564
tags: Outopos Draft gREEN [[That's for you to decide]]
title: Outopos: Logical P2P Accounts

//Hereinlies the ravings of a retard. Assume it is wrong. If you're generous enough, show me the way.//

!! [[W5H]] is a logical p2p account?

An offline-first, airgap-reproducible, decentralizable self-sovereign identity to which other disavowable identities, devices, or data can be provably associated, disassociated, nested, orchestrated, and controlled by the underlying root identity key-holder. It is not intended to generate disposable identities but rather enable a user to recover or revoke rights to particular devices, identities, or data without a central (including federated) authority. 

Without logical accounts (or something equivalent), single-user multi-device functions, offline messaging, proxy representation, and [[NAT Traversal]] are difficult or impossible to completely achieve on secure, strictly distributed p2p networks. 

Ideally, a user can walk up to a brand new machine and recreate the fundamental keys to their identity from scratch and memory using FLOSS tools without asking anyone's permission. They should also be able to issue authenticated commands to other devices from any device on the logical account, and disavow associated accounts or devices in public (including deleting information off a DHT). We need portable, self-authenticating decentralizable identity and content-addressable key management suitable for next generation DHTs and their overlays.

This spec is written on the assumption of prioritizing the needs of fully distributed p2p networks. Every other usecase is secondary in our requirements.

<br>

!! Authentication:

* Masterkey := PBKDF(username + password + known_salt) with strong settings
** This is never left on any hard drive. Ideally, we can memorize the input information.
*** Note the responsibility of the user to manage their own secrets. That's what this process is all about. No one else can do it for them without having lost at least some ownership of the means of identity production. 
** Used to generate signature keys for Ed25519, CRYSTALS-Dilithium, and perhaps 1-3 more PQC Signature systems for diversity's sake (PQC is an unknown, even SIKE was pwned). We should assume the need for modularity here.
** In the end, a user could lose control of all their devices but still regain control of their root identity with this key.
** Because uniqueness is especially critical in this case, consider default enforcement for complex passwords, with a convenient way to bypass it. 
*** Though they aren't computationally different, we might performatively distinguish "create account" from "login", at least providing a chance to search the DHT as an additional check for current uniqueness. 
** Hardware authentication compatibility seems worthy.
** In some cases, this known_salt may a worthy variable for distinguishing between different accounts that share the same username and password, be it the user's explicit choice or an application's. It's not like the salt should be stored anywhere either. 
*** In most cases, however, the Masterkey is ideally used to authorize, if not outright generate, the keychains that would eventually be used by a suitable application. 
**** It is also technically possible to use this authentication framework as the basis of a stateless password manager, but it may be wiser, in the end, to use the Masterkey to eventually synchronize a password manager's encrypted files instead.

* Master Private Signature Keys := PBKDF(Masterkey + signature type + known_salt) with strong settings, then deterministically truncated, stretched, or formatted for each signature algorithm's private key requirements 
** Where signature type is Ed25519, CRYSTALS-Dilithium, etc.
** This is never left on any hard drive. Ideally, we generate these keys only when we need to multisign Slavekeys or something similarly exceptional.
** If one signature algorithm ends up failing, the Masterkey still can't be recovered. Only one signature system needs to hold, even if we don't know which one.
 
* Master Public Signature Keys := Each generated by their respective signature algorithm
** These keys can be distributed across all private and public devices that want them. Assume adversaries have a copy of these keys.
*** With these in hand, any device has the capacity to verify a Masterkey-holder has disavowed older Slavekeys, authenticated new ones, or perhaps authorized other uncommon behaviors.
** These keys can be generated on each device by first temporarily generating the Masterkey, or they can be transferred by other means.
*** For the paranoid, it may be preferred that they are transferred from an airgapped machine rather than generated on the destination device, as we might not be able to trust the destination device to generate the keys.
**** Convenience matters though. Make it simple for both cases. 
**** After creating a Logical Account Slavekey, make sure no Masterkey nor Master Private Signature Keys are left in memory (and they shouldn't be written to the drive in the first place).
** Can be used, for example, as the nodeID of a mutable torrent arising from a DHT, where the value stored includes the signature of the rest of the value stored, including a counter for updates.
*** Because it will be rare and quite expensive to generate the Masterkey, the Slavekey(s) should do most of the real work.
*** Lookups could provide the last known signed list of Slavekey(s), including perhaps Devicekey(s).

<br>

* Logical Account Slavekey := PBKDF(Masterkey + counter + optional_unique_ID + known_salt)
** If at all, this key is to be found only on user's associated devices. 
*** Note that this key can be disavowed and replaced in case it is (or perhaps any downstream keys are) compromised or stolen.
*** 
*** Multisigned by Master Signature Keys, these signatures sit on every device of the logical account as well.
** optional_unique_ID allows for a keyring of Logical Account Slavekeys constructed from the Masterkey
** Deterministically generated so we can remotely bootstrap devices of a logical account without any network, introducers, or manual verification from other devices.
*** Most users will prefer network access to a DHT that can enable users not to have to remember their counters.
** Could use weak PBKDF setting given the high entropy of the Masterkey/

*** Weak settings because we may have to generate a number of these to find the current Logical Account Slavekey, and the Masterkey already has significant entropy. 
*** Either the counter is memorized or you go online and search up by master or old slavekeys to find the current counter. 
*** N


* Logical Account Private Signature Keys := PBKDF(Logical Account Slavekey + signature type + known_salt) with weak settings, deterministically truncated, stretched, or formatted for the signature algorithm's private key requirements 
** Where signature type is Ed25519, CRYSTALS-Dilithium, etc.
** These keys are to be found only on each of the user's devices.

* Logical Account Public Signature Keys := Each generated by their respective signature algorithm
** These keys can be distributed across all private and public devices that want them.
** Multisigned by Master Signature Keys, these signatures can be distributed across all private and public devices that want them.

* Logical Account Proofing :=
** A very thin Proof of Work may help keep honest individuals honest. It's a verifiable speedbump.
** Proof of Storage may ensure trust in the key-value store.

* Logical Account Key-exchange-agreement Private Keys := PBKDF(Logical Account Slavekey + key-exchange-agreement type + known_salt) with weak settings, deterministically truncated, stretched, or formatted for the key-exchange-agreement algorithm's private key requirements 
** Where key-exchange-agreement is X25519, CRYSTALS-Kyber, etc.
** These keys are to be found only on each of the user's devices.

* Logical Account Key-exchange-agreement Public Keys := Each generated by their respective Key-exchange-agreement algorithm
** These keys can be distributed across all private and public devices that want them.
** Multisigned by Master Signature Keys, these keys can be distributed across all private and public devices that want them. 

---

* Nesting Logical Accounts




* Device Keys:

* Initial Ephemeral Keys:

* PSK-Secured Emphemeral Private Key:

* PSK-Secured Emphemeral Public Key:
** Elligator is not required here because transmission of the ephemeral public keys will be encrypted by the symmetric key generated from the PSKs, which appears no different than random.






















444444444444444
*** Note that we could provide an option for manually verifying the addition of new devices from legacy trusted devices.
444444444444444
** The counter represents repudiations, where we manually have switched to the next key. Ideally, this is rare. 
*** When a device seeks to join the network of the user's logical account, it will begin with the bottom counter unless the user specifies otherwise and iterate up. 
** Repudiating a device can be as simple as not transmitting the new Logical Account Slavekey to the untrusted device.
*** Untrusted devices will not have a Masterkey to generate the next iteration of the Logical Account Slavekey, so they won't be able to find or antagonize veteran devices on the logical account's network (unless they've a mole*), and they won't be able to masquerade as a legitimate device for long either.
**** Untrusted devices should recieve no response (only possible over UDP).





* Logical Account DHT Key(s) := SHA-512(Logical Account Slavekey + Nospam? + Checksum)

truncatedd? No. they need a signing pubkey.



** Concurrent exploration of the DHT Key space (given Logical Account Slavekey iteration space)
*** Quadratic forward exploration of the key iteration space, then search by midpoints.
**** If the logical account's current counter is 0:
***** Two processes, one with counter=0 and counter=1. The first process is successful, and the second isn't. Success.
***** 2 processes is the minimum necessary to find counter=0 as fast as possible.
**** If the logical account's current counter is 13:
***** Two processes, one with counter=0 and counter=1. Do they exist? Yes. Check at counter=4? Does it exist? Yes. Check at counter=16. Does it exist? No. Check at counter=8. Does it exist? Yes. Check at counter=12. Does it exist? Yes. Check at counter=14. Does it exist? No. Check at counter=13. Does it exist? Yes. Success.


** This key is used to generate the entry point of the logical account on the DHT. Every device on the logical account can participate with this key. 
*** Ideally, when hunting on the DHT for the devices of a logical account, a user asks multiple nodes on the DHT, and it may receive different answers (IP addresses). 
*** 





* Public Devices, Private Devices
** For various reasons, a user might not want (or even be able) to have all of their devices on their logical account be publically facing. 






